import { getDbClient, schema, eq, type User as DBUserType, type Session as DBSessionType } from "@tenstack/db";
import type { StandardUserContext } from "./context.js"; // For regular user context

import { encodeBase32LowerCaseNoPadding, encodeHexLowerCase } from "@oslojs/encoding";
import { sha256 } from "@oslojs/crypto/sha2";

// Define the required DB client type based on the factory function
type DbClient = ReturnType<typeof getDbClient>;

// Use the types via the imported schema namespace
export type User = DBUserType;
export type Session = DBSessionType;

// SessionValidationResult for regular Medusa customer sessions
export type SessionValidationResult =
	| { session: Session; user: StandardUserContext } // User is StandardUserContext
	| { session: null; user: null };

/**
 * Generates a secure, random session token.
 * Uses 20 random bytes encoded in base32 for case-insensitivity and URL safety.
 */
export function generateSessionToken(): string {
	const bytes = new Uint8Array(20);
	crypto.getRandomValues(bytes); // Uses Web Crypto API
	const token = encodeBase32LowerCaseNoPadding(bytes);
	return token;
}

/**
 * Creates a new session in the database.
 * Hashes the provided token to generate the session ID.
 * Sets expiration to 30 days from now.
 * @param db The database client instance.
 * @param token The raw session token generated by generateSessionToken().
 * @param userId The ID of the user (e.g., Medusa customer ID 'cus_...').
 * @returns The created Session object.
 */
export async function createSession(db: DbClient, token: string, userId: string): Promise<Session> {
	const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token))); // Use the raw token to create the ID
	const sessionData: Session = {
		id: sessionId,
		userId: userId, // Ensure this matches the text type from your schema
		expiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24 * 30), // 30 days expiration
	};
	// Use schema namespace to access table
	await db.insert(schema.sessionsTable).values(sessionData);
	return sessionData;
}

/**
 * Validates a session token provided by the client.
 * 1. Hashes the token to find the corresponding session ID.
 * 2. Checks if the session exists and fetches the associated user.
 * 3. Verifies the session has not expired.
 * 4. Extends the session expiration if it's within the renewal threshold (last 15 days).
 * @param db The database client instance.
 * @param token The raw session token from the client cookie.
 * @returns A SessionValidationResult containing the session and user, or null for both if invalid.
 */
export async function validateSessionToken(db: DbClient, token: string): Promise<SessionValidationResult> {
	// Hash the raw token from the cookie to get the ID stored in the DB
	const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));

	// Use schema namespace to access tables
	const result = await db
		.select({ user: schema.usersTable, session: schema.sessionsTable })
		.from(schema.sessionsTable)
		.innerJoin(schema.usersTable, eq(schema.sessionsTable.userId, schema.usersTable.id))
		.where(eq(schema.sessionsTable.id, sessionId)); // Use the hashed ID for lookup

	// No session found for this ID
	if (result.length < 1) {
		return { session: null, user: null };
	}

	const { user: dbUser, session } = result[0];

	// Check if the session has expired
	if (Date.now() >= session.expiresAt.getTime()) {
		// Clean up expired session from the database
		// Use schema namespace to access table
		await db.delete(schema.sessionsTable).where(eq(schema.sessionsTable.id, session.id));
		return { session: null, user: null };
	}

	// Session Sliding Window: Extend expiration if within the renewal period (e.g., last 15 days of 30)
	// This keeps active users logged in without requiring them to log in again frequently.
	const renewalThreshold = 1000 * 60 * 60 * 24 * 15; // 15 days
	if (Date.now() >= session.expiresAt.getTime() - renewalThreshold) {
		const newExpiresAt = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30); // Extend by 30 days from now
		// Use schema namespace to access table
		await db
			.update(schema.sessionsTable)
			.set({
				expiresAt: newExpiresAt,
			})
			.where(eq(schema.sessionsTable.id, session.id));
		// Update the session object in memory to reflect the new expiration
		session.expiresAt = newExpiresAt;
	}

	// Construct the StandardUserContext
	const standardUser: StandardUserContext = {
		id: dbUser.id,
		// Assuming regular Medusa users have a default role of 'customer' for context purposes.
		// This 'role' is purely for the tRPC Context, not necessarily stored on usersTable unless you added it.
		role: 'customer', 
	};

	// Session is valid, return the session and user details
	return { session, user: standardUser };
}

/**
 * Invalidates a specific session by deleting it from the database.
 * Requires the database client instance and the session ID (hashed token), not the raw token.
 * @param db The database client instance.
 * @param sessionId The SHA-256 hash of the session token (the ID stored in the database).
 */
export async function invalidateSession(db: DbClient, tokenFromCookie: string): Promise<void> {
	// Only invalidate from regular sessionsTable
	const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(tokenFromCookie)));
	try {
		await db.delete(schema.sessionsTable).where(eq(schema.sessionsTable.id, sessionId));
	} catch (error) {
		console.warn("Failed to delete from sessionsTable or session not found:", error);
	}
}

/**
 * Invalidates all sessions associated with a specific user ID.
 * Useful for "log out everywhere" functionality.
 * @param db The database client instance.
 * @param userId The ID of the user whose sessions should be invalidated.
 */
export async function invalidateAllSessions(db: DbClient, userId: string): Promise<void> {
	// Use schema namespace to access table
	await db.delete(schema.sessionsTable).where(eq(schema.sessionsTable.userId, userId));
} 